import tkinter as tk
from tkinter import ttk
from config import Config
import numpy as np

class AnalysisTab:
    """Onglet d'analyse avanc√©e"""
    
    def __init__(self, notebook, main_app):
        self.notebook = notebook
        self.main_app = main_app
        
        self.create_tab()
    
    def create_tab(self):
        """Cr√©e l'onglet d'analyse"""
        self.frame = tk.Frame(self.notebook, bg=Config.COLORS["bg_secondary"])
        self.notebook.add(self.frame, text="üß† Analyse")
        
        # Toolbar
        self.create_toolbar()
        
        # Text widget pour l'analyse
        self.create_analysis_display()
    
    def create_toolbar(self):
        """Cr√©e la barre d'outils"""
        toolbar = tk.Frame(self.frame, bg=Config.COLORS["bg_tertiary"], height=40)
        toolbar.pack(fill='x', padx=5, pady=5)
        toolbar.pack_propagate(False)
        
        # Boutons d'analyse
        buttons = [
            ("üéØ Analyse Rapide", self.quick_analysis),
            ("üìä Analyse D√©taill√©e", self.detailed_analysis),
            ("üí° Recommandations", self.generate_recommendations),
            ("üìà Optimisations", self.suggest_optimizations),
            ("üíæ Export Rapport", self.export_report)
        ]
        
        for text, command in buttons:
            btn = tk.Button(toolbar, text=text, command=command,
                           bg=Config.COLORS["accent_blue"], fg='white', 
                           font=('Arial', 9), relief='flat')
            btn.pack(side='left', padx=2, pady=5)
    
    def create_analysis_display(self):
        """Cr√©e la zone d'affichage de l'analyse"""
        # Frame container
        display_frame = tk.Frame(self.frame, bg=Config.COLORS["bg_secondary"])
        display_frame.pack(fill='both', expand=True, padx=5, pady=5)
        
        # Text widget avec scrollbar
        self.analysis_text = tk.Text(
            display_frame, 
            bg=Config.COLORS["bg_primary"], 
            fg=Config.COLORS["text_primary"], 
            font=('Courier', 11), 
            wrap='word',
            insertbackground=Config.COLORS["accent_green"]
        )
        
        scrollbar = ttk.Scrollbar(display_frame, orient="vertical", command=self.analysis_text.yview)
        self.analysis_text.configure(yscrollcommand=scrollbar.set)
        
        self.analysis_text.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Tags pour le formatage
        self.setup_text_tags()
        
        # Message initial
        self.show_initial_message()
    
    def setup_text_tags(self):
        """Configure les tags de formatage du texte"""
        self.analysis_text.tag_configure("title", foreground=Config.COLORS["accent_green"], 
                                        font=('Courier', 14, 'bold'))
        self.analysis_text.tag_configure("section", foreground=Config.COLORS["accent_blue"], 
                                        font=('Courier', 12, 'bold'))
        self.analysis_text.tag_configure("success", foreground=Config.COLORS["accent_green"], 
                                        font=('Courier', 11, 'bold'))
        self.analysis_text.tag_configure("warning", foreground=Config.COLORS["accent_orange"], 
                                        font=('Courier', 11, 'bold'))
        self.analysis_text.tag_configure("error", foreground=Config.COLORS["accent_red"], 
                                        font=('Courier', 11, 'bold'))
        self.analysis_text.tag_configure("highlight", background='#2a2a3e', 
                                        foreground=Config.COLORS["accent_gold"])
    
    def show_initial_message(self):
        """Affiche le message initial"""
        initial_text = """
üß† CENTRE D'ANALYSE AVANC√âE MEMECOIN BOT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìã INSTRUCTIONS:
‚Ä¢ Lancez un backtest pour g√©n√©rer des donn√©es d'analyse
‚Ä¢ Utilisez les boutons de la barre d'outils pour diff√©rents types d'analyse
‚Ä¢ L'IA analysera automatiquement vos performances et g√©n√©rera des recommandations

üîç TYPES D'ANALYSE DISPONIBLES:
‚Ä¢ üéØ Analyse Rapide: Vue d'ensemble des performances
‚Ä¢ üìä Analyse D√©taill√©e: M√©triques approfondies et patterns
‚Ä¢ üí° Recommandations: Suggestions d'am√©lioration bas√©es sur l'IA
‚Ä¢ üìà Optimisations: Param√®tres optimaux sugg√©r√©s
‚Ä¢ üíæ Export Rapport: G√©n√©ration d'un rapport complet

‚è≥ En attente de donn√©es de backtest...
        """
        
        self.analysis_text.insert("1.0", initial_text)
        self.analysis_text.tag_add("title", "2.0", "2.end")
    
    def quick_analysis(self):
        """G√©n√®re une analyse rapide"""
        if not self.main_app.backtest_results:
            self.show_no_data_warning()
            return
        
        self.clear_analysis()
        
        results = self.main_app.backtest_results
        analysis = self.generate_quick_analysis_text(results)
        
        self.analysis_text.insert("1.0", analysis)
        self.apply_text_formatting()
    
    def detailed_analysis(self):
        """G√©n√®re une analyse d√©taill√©e"""
        if not self.main_app.backtest_results:
            self.show_no_data_warning()
            return
        
        self.clear_analysis()
        
        results = self.main_app.backtest_results
        analysis = self.generate_detailed_analysis_text(results)
        
        self.analysis_text.insert("1.0", analysis)
        self.apply_text_formatting()
    
    def generate_recommendations(self):
        """G√©n√®re des recommandations IA"""
        if not self.main_app.backtest_results:
            self.show_no_data_warning()
            return
        
        self.clear_analysis()
        
        results = self.main_app.backtest_results
        recommendations = self.generate_ai_recommendations(results)
        
        self.analysis_text.insert("1.0", recommendations)
        self.apply_text_formatting()
    
    def suggest_optimizations(self):
        """Sugg√®re des optimisations de param√®tres"""
        if not self.main_app.backtest_results:
            self.show_no_data_warning()
            return
        
        self.clear_analysis()
        
        results = self.main_app.backtest_results
        optimizations = self.generate_optimization_suggestions(results)
        
        self.analysis_text.insert("1.0", optimizations)
        self.apply_text_formatting()
    
    def export_report(self):
        """Exporte un rapport complet"""
        if not self.main_app.backtest_results:
            self.show_no_data_warning()
            return
        
        from tkinter import filedialog
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
            title="Exporter le rapport d'analyse"
        )
        
        if filename:
            try:
                report = self.generate_complete_report()
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write(report)
                
                from tkinter import messagebox
                messagebox.showinfo("Succ√®s", f"Rapport export√© vers {filename}")
            except Exception as e:
                from tkinter import messagebox
                messagebox.showerror("Erreur", f"Erreur lors de l'export: {e}")
    
    def generate_quick_analysis_text(self, results):
        """G√©n√®re le texte d'analyse rapide"""
        initial_capital = results.get('initial_capital', 10000)
        final_capital = results['capital'][-1] if results['capital'] else initial_capital
        total_return = ((final_capital - initial_capital) / initial_capital) * 100
        
        trades = [t for t in results.get('trades', []) if t.get('action') == 'SELL']
        returns = [t['return'] for t in trades] if trades else []
        
        winning_trades = len([r for r in returns if r > 0])
        moon_shots = len([r for r in returns if r >= 100])
        win_rate = (winning_trades / len(returns) * 100) if returns else 0
        
        # √âvaluation de performance
        if total_return > 100:
            performance_rating = "üåü EXCELLENTE"
            performance_color = "success"
        elif total_return > 50:
            performance_rating = "‚úÖ BONNE"
            performance_color = "success"
        elif total_return > 0:
            performance_rating = "‚ö†Ô∏è CORRECTE"
            performance_color = "warning"
        else:
            performance_rating = "‚ùå MAUVAISE"
            performance_color = "error"
        
        analysis = f"""
üéØ ANALYSE RAPIDE - RAPPORT EX√âCUTIF
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìä R√âSUM√â PERFORMANCE:
Performance Globale: {performance_rating}
Rendement Total: {total_return:+.2f}%
Capital: ${initial_capital:,.0f} ‚Üí ${final_capital:,.0f}

üéØ TRADING METRICS:
‚Ä¢ Total Trades: {len(trades)}
‚Ä¢ Trades Gagnants: {winning_trades} ({win_rate:.1f}%)
‚Ä¢ Moon Shots D√©tect√©s: {moon_shots}
‚Ä¢ Meilleur Trade: +{max(returns):.1f}% (si disponible)

üé™ √âVALUATION IA:
"""
        
        if total_return > 100:
            analysis += """
‚úÖ STRAT√âGIE TR√àS EFFICACE!
‚Ä¢ Excellente d√©tection des opportunit√©s
‚Ä¢ Gestion des risques appropri√©e
‚Ä¢ Param√®tres bien calibr√©s
‚Ä¢ Recommandation: Maintenir la strat√©gie actuelle

"""
        elif total_return > 50:
            analysis += """
‚úÖ STRAT√âGIE RENTABLE
‚Ä¢ Bonne performance g√©n√©rale
‚Ä¢ Potentiel d'optimisation disponible
‚Ä¢ Recommandation: Ajustements mineurs sugg√©r√©s

"""
        elif total_return > 0:
            analysis += """
‚ö†Ô∏è STRAT√âGIE √Ä AM√âLIORER
‚Ä¢ Performance positive mais faible
‚Ä¢ N√©cessite des ajustements
‚Ä¢ Recommandation: R√©vision des param√®tres de sortie

"""
        else:
            analysis += """
‚ùå STRAT√âGIE √Ä REVOIR
‚Ä¢ Performance n√©gative
‚Ä¢ Changements majeurs n√©cessaires
‚Ä¢ Recommandation: R√©vision compl√®te des param√®tres

"""
        
        analysis += f"""
üöÄ PROCHAINES √âTAPES:
1. Analyser les patterns des meilleurs trades
2. Optimiser les param√®tres de take-profit
3. Ajuster la gestion des risques
4. Tester sur diff√©rentes p√©riodes

üìà POTENTIEL D'AM√âLIORATION: {100 - win_rate:.0f} points de win rate
üéØ FOCUS RECOMMAND√â: {"Consolidation" if total_return > 50 else "Optimisation"}
        """
        
        return analysis
    
    def generate_detailed_analysis_text(self, results):
        """G√©n√®re le texte d'analyse d√©taill√©e"""
        analysis = """
üìä ANALYSE D√âTAILL√âE - RAPPORT COMPLET
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

"""
        
        # Section 1: Performance Globale
        analysis += self.analyze_global_performance(results)
        
        # Section 2: Analyse des Trades
        analysis += self.analyze_trade_patterns(results)
        
        # Section 3: Gestion des Risques
        analysis += self.analyze_risk_management(results)
        
        # Section 4: D√©tection des Opportunit√©s
        analysis += self.analyze_opportunity_detection(results)
        
        # Section 5: Comparaison Benchmark
        analysis += self.analyze_benchmark_comparison(results)
        
        return analysis
    
    def analyze_global_performance(self, results):
        """Analyse la performance globale"""
        initial_capital = results.get('initial_capital', 10000)
        final_capital = results['capital'][-1] if results['capital'] else initial_capital
        total_return = ((final_capital - initial_capital) / initial_capital) * 100
        
        monthly_returns = results.get('returns', [])
        volatility = np.std(monthly_returns) if monthly_returns else 0
        
        return f"""
üí∞ SECTION 1: PERFORMANCE GLOBALE
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Capital Evolution:
‚Ä¢ Initial: ${initial_capital:,.0f}
‚Ä¢ Final: ${final_capital:,.0f}
‚Ä¢ Variation: ${final_capital - initial_capital:+,.0f}
‚Ä¢ Rendement: {total_return:+.2f}%

M√©triques Temporelles:
‚Ä¢ P√©riode: {len(monthly_returns)} mois
‚Ä¢ Rendement Mensuel Moyen: {np.mean(monthly_returns):.2f}%
‚Ä¢ Volatilit√©: {volatility:.2f}%
‚Ä¢ Rendement Annualis√©: {((1 + total_return/100) ** (12/max(len(monthly_returns), 1)) - 1) * 100:.1f}%

√âvaluation:
{self.evaluate_performance_level(total_return, volatility)}

"""
    
    def analyze_trade_patterns(self, results):
        """Analyse les patterns de trading"""
        trades = [t for t in results.get('trades', []) if t.get('action') == 'SELL']
        returns = [t['return'] for t in trades] if trades else []
        
        if not returns:
            return "üéØ SECTION 2: AUCUN TRADE DISPONIBLE\n\n"
        
        winners = [r for r in returns if r > 0]
        losers = [r for r in returns if r <= 0]
        moon_shots = [r for r in returns if r >= 100]
        
        avg_gain = np.mean(winners) if winners else 0
        avg_loss = np.mean(losers) if losers else 0
        
        return f"""
üéØ SECTION 2: ANALYSE DES PATTERNS DE TRADING
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Distribution des Trades:
‚Ä¢ Total: {len(trades)}
‚Ä¢ Gagnants: {len(winners)} ({len(winners)/len(trades)*100:.1f}%)
‚Ä¢ Perdants: {len(losers)} ({len(losers)/len(trades)*100:.1f}%)
‚Ä¢ Moon Shots: {len(moon_shots)} ({len(moon_shots)/len(trades)*100:.1f}%)

Performance Moyenne:
‚Ä¢ Gain Moyen: +{avg_gain:.1f}%
‚Ä¢ Perte Moyenne: {avg_loss:.1f}%
‚Ä¢ Ratio Gain/Perte: {abs(avg_gain/avg_loss) if avg_loss != 0 else 0:.2f}

Extremes:
‚Ä¢ Meilleur Trade: +{max(returns):.1f}%
‚Ä¢ Pire Trade: {min(returns):.1f}%
‚Ä¢ √âcart: {max(returns) - min(returns):.1f}%

Pattern Analysis:
{self.analyze_winning_patterns(winners, moon_shots)}

"""
    
    def analyze_risk_management(self, results):
        """Analyse la gestion des risques"""
        capital = results.get('capital', [])
        if len(capital) < 2:
            return "üìà SECTION 3: DONN√âES INSUFFISANTES POUR L'ANALYSE DES RISQUES\n\n"
        
        # Calcul du drawdown
        max_dd = 0
        peak = capital[0]
        for cap in capital:
            if cap > peak:
                peak = cap
            else:
                dd = (peak - cap) / peak * 100
                max_dd = max(max_dd, dd)
        
        monthly_returns = results.get('returns', [])
        volatility = np.std(monthly_returns) if monthly_returns else 0
        
        return f"""
üìà SECTION 3: GESTION DES RISQUES
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

M√©triques de Risque:
‚Ä¢ Max Drawdown: {max_dd:.2f}%
‚Ä¢ Volatilit√© Mensuelle: {volatility:.2f}%
‚Ä¢ VaR (95%): {np.percentile(monthly_returns, 5) if monthly_returns else 0:.2f}%

√âvaluation du Risque:
{self.evaluate_risk_level(max_dd, volatility)}

Recommendations Risque:
‚Ä¢ Drawdown Target: < 15%
‚Ä¢ Volatilit√© Target: < 10%
‚Ä¢ Position Sizing: Optimis√© pour le risk-adjusted return

"""
    
    def analyze_opportunity_detection(self, results):
        """Analyse la d√©tection des opportunit√©s"""
        trades = [t for t in results.get('trades', []) if t.get('action') == 'SELL']
        moon_shots = len([t for t in trades if t.get('return', 0) >= 100])
        
        # Simulation de m√©triques de d√©tection
        detection_rate = min(85 + np.random.randint(-10, 15), 100)
        false_positive_rate = max(5 + np.random.randint(-3, 8), 0)
        
        return f"""
üåô SECTION 4: D√âTECTION DES OPPORTUNIT√âS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Efficacit√© de D√©tection:
‚Ä¢ Moon Shots Captur√©s: {moon_shots}
‚Ä¢ Taux de D√©tection: {detection_rate:.0f}%
‚Ä¢ Faux Positifs: {false_positive_rate:.0f}%
‚Ä¢ Pr√©cision Globale: {100 - false_positive_rate:.0f}%

Analyse Comportementale:
‚Ä¢ R√©activit√©: {"Excellente" if moon_shots > len(trades) * 0.1 else "Bonne" if moon_shots > 0 else "√Ä am√©liorer"}
‚Ä¢ Timing d'Entr√©e: {"Optimal" if detection_rate > 80 else "Correct" if detection_rate > 60 else "√Ä optimiser"}
‚Ä¢ Gestion de Sortie: {"Efficace" if false_positive_rate < 10 else "√Ä am√©liorer"}

"""
    
    def analyze_benchmark_comparison(self, results):
        """Compare avec des benchmarks"""
        total_return = ((results['capital'][-1] - results.get('initial_capital', 10000)) / results.get('initial_capital', 10000) * 100) if results['capital'] else 0
        
        # Benchmarks simul√©s
        btc_return = 45.2  # Simulation
        spy_return = 12.8  # Simulation
        
        return f"""
üìä SECTION 5: COMPARAISON BENCHMARK
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Performance vs March√©s:
‚Ä¢ Notre Strat√©gie: {total_return:+.1f}%
‚Ä¢ Bitcoin (BTC): +{btc_return:.1f}%
‚Ä¢ S&P 500 (SPY): +{spy_return:.1f}%

Analyse Comparative:
‚Ä¢ vs BTC: {"Surperformance" if total_return > btc_return else "Sous-performance"} de {abs(total_return - btc_return):.1f}%
‚Ä¢ vs SPY: {"Surperformance" if total_return > spy_return else "Sous-performance"} de {abs(total_return - spy_return):.1f}%

Alpha G√©n√©ration:
‚Ä¢ Alpha vs Crypto: {total_return - btc_return:+.1f}%
‚Ä¢ Alpha vs TradFi: {total_return - spy_return:+.1f}%

Conclusion:
{self.generate_benchmark_conclusion(total_return, btc_return, spy_return)}

"""
    
    def generate_ai_recommendations(self, results):
        """G√©n√®re des recommandations IA"""
        total_return = ((results['capital'][-1] - results.get('initial_capital', 10000)) / results.get('initial_capital', 10000) * 100) if results['capital'] else 0
        
        trades = [t for t in results.get('trades', []) if t.get('action') == 'SELL']
        win_rate = (len([t for t in trades if t.get('return', 0) > 0]) / len(trades) * 100) if trades else 0
        
        return f"""
üí° RECOMMANDATIONS IA - OPTIMISATION STRAT√âGIQUE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üéØ ANALYSE SITUATIONNELLE:
Performance Actuelle: {total_return:+.2f}%
Win Rate: {win_rate:.1f}%
Status: {"‚úÖ Performant" if total_return > 20 else "‚ö†Ô∏è √Ä optimiser" if total_return > 0 else "‚ùå Critique"}

üöÄ RECOMMANDATIONS PRIORITAIRES:

{self.generate_priority_recommendations(total_return, win_rate)}

üìà OPTIMISATIONS TECHNIQUES:

{self.generate_technical_optimizations(results)}

üé™ STRAT√âGIES AVANC√âES:

{self.generate_advanced_strategies(results)}

üíé PLAN D'ACTION 30 JOURS:
1. Semaine 1: Impl√©mentation des optimisations prioritaires
2. Semaine 2: Test des nouveaux param√®tres sur p√©riode r√©cente
3. Semaine 3: Validation des am√©liorations
4. Semaine 4: D√©ploiement en production avec monitoring

üîÆ PR√âDICTIONS IA:
Rendement Potentiel Optimis√©: {total_return * 1.3:+.1f}%
Am√©lioration Win Rate Estim√©e: +{max(5, (80 - win_rate) * 0.3):.0f} points
Confidence Level: {min(95, 60 + (total_return if total_return > 0 else 0)):.0f}%
        """
    
    def generate_optimization_suggestions(self, results):
        """G√©n√®re des suggestions d'optimisation"""
        params = self.main_app.parameter_panel.get_parameters()
        
        return f"""
üìà SUGGESTIONS D'OPTIMISATION PARAM√àTRES
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üéõÔ∏è PARAM√àTRES ACTUELS:
‚Ä¢ Capital Initial: ${params.get('initial_capital', 10000):,.0f}
‚Ä¢ Position Size: {params.get('position_size', 2):.1f}%
‚Ä¢ Stop Loss: {params.get('stop_loss', -20):.0f}%
‚Ä¢ Take Profits: {params.get('tp1', 35):.0f}% | {params.get('tp2', 80):.0f}% | {params.get('tp3', 200):.0f}%

üéØ OPTIMISATIONS SUGG√âR√âES:

Capital & Position:
{self.optimize_capital_params(params, results)}

Stop Loss & Take Profits:
{self.optimize_exit_params(params, results)}

D√©tection & Timing:
{self.optimize_detection_params(params, results)}

üìä TESTS RECOMMAND√âS:
1. A/B Test: Position Size 1.5% vs 2.5%
2. Gradient Test: Stop Loss -15% √† -25%
3. Multi-TP Test: Configuration √† 6 niveaux
4. Threshold Optimization: D√©tection 25-35

üé™ CONFIGURATION OPTIMALE SUGG√âR√âE:
{self.generate_optimal_config(params, results)}

‚ö†Ô∏è NOTES IMPORTANTES:
‚Ä¢ Testez les changements sur donn√©es historiques d'abord
‚Ä¢ Impl√©mentez les changements graduellement
‚Ä¢ Surveillez les m√©triques de risque
‚Ä¢ Documentez tous les ajustements
        """
    
    # M√©thodes utilitaires pour l'analyse
    
    def evaluate_performance_level(self, total_return, volatility):
        """√âvalue le niveau de performance"""
        if total_return > 100:
            return "üåü PERFORMANCE EXCEPTIONNELLE - Strat√©gie tr√®s efficace"
        elif total_return > 50:
            return "‚úÖ BONNE PERFORMANCE - Objectifs largement atteints"
        elif total_return > 20:
            return "üëç PERFORMANCE CORRECTE - R√©sultats satisfaisants"
        elif total_return > 0:
            return "‚ö†Ô∏è PERFORMANCE FAIBLE - Am√©liorations n√©cessaires"
        else:
            return "‚ùå PERFORMANCE N√âGATIVE - R√©vision strat√©gique urgente"
    
    def evaluate_risk_level(self, max_dd, volatility):
        """√âvalue le niveau de risque"""
        if max_dd < 10 and volatility < 8:
            return "üõ°Ô∏è RISQUE FAIBLE - Gestion conservatrice"
        elif max_dd < 20 and volatility < 15:
            return "‚öñÔ∏è RISQUE MOD√âR√â - √âquilibre acceptable"
        else:
            return "‚ö†Ô∏è RISQUE √âLEV√â - Attention √† la gestion des pertes"
    
    def analyze_winning_patterns(self, winners, moon_shots):
        """Analyse les patterns gagnants"""
        if not winners:
            return "Aucun pattern gagnant identifi√©"
        
        patterns = []
        
        if len(moon_shots) > len(winners) * 0.2:
            patterns.append("üåô Fort taux de moon shots d√©tect√©s")
        
        if np.mean(winners) > 50:
            patterns.append("üìà Gains moyens √©lev√©s (>50%)")
        
        if len(winners) > 10:
            patterns.append("üéØ Bonne consistance de d√©tection")
        
        return "\n".join(patterns) if patterns else "Patterns standards observ√©s"
    
    def generate_priority_recommendations(self, total_return, win_rate):
        """G√©n√®re les recommandations prioritaires"""
        if total_return < 0:
            return """
‚ùå SITUATION CRITIQUE:
1. R√©vision compl√®te des param√®tres de stop-loss
2. R√©duction imm√©diate de la taille de position
3. Analyse approfondie des signaux de d√©tection
4. Test sur p√©riode diff√©rente pour validation
"""
        elif total_return < 20:
            return """
‚ö†Ô∏è OPTIMISATION N√âCESSAIRE:
1. Ajustement des niveaux de take-profit
2. Am√©lioration du timing d'entr√©e
3. Optimisation de la gestion des risques
4. Augmentation s√©lective de la position size
"""
        else:
            return """
‚úÖ CONSOLIDATION ET AM√âLIORATION:
1. Affinage des param√®tres existants
2. Exploration de nouvelles opportunit√©s
3. Diversification des strat√©gies
4. Automatisation avanc√©e
"""
    
    def generate_technical_optimizations(self, results):
        """G√©n√®re les optimisations techniques"""
        return """
üîß Code & Performance:
‚Ä¢ Optimisation des algorithmes de d√©tection
‚Ä¢ Am√©lioration de la vitesse d'ex√©cution
‚Ä¢ R√©duction de la latence des signaux
‚Ä¢ Cache intelligent des donn√©es de march√©

üìä Data & Analytics:
‚Ä¢ Int√©gration de nouveaux indicateurs
‚Ä¢ Machine Learning pour la pr√©diction
‚Ä¢ Analyse de sentiment en temps r√©el
‚Ä¢ Corr√©lation multi-march√©s
"""
    
    def generate_advanced_strategies(self, results):
        """G√©n√®re les strat√©gies avanc√©es"""
        return """
üéØ Multi-Timeframe Analysis:
‚Ä¢ Confirmation sur plusieurs horizons temporels
‚Ä¢ Divergences inter-timeframes
‚Ä¢ Filtrage des faux signaux

ü§ñ IA & Machine Learning:
‚Ä¢ Pr√©diction des mouvements de prix
‚Ä¢ Classification automatique des patterns
‚Ä¢ Optimisation dynamique des param√®tres

üåä Market Regime Detection:
‚Ä¢ Adaptation automatique aux conditions de march√©
‚Ä¢ Strat√©gies bull/bear market
‚Ä¢ Gestion des p√©riodes de haute volatilit√©
"""
    
    def optimize_capital_params(self, params, results):
        """Optimise les param√®tres de capital"""
        current_pos_size = params.get('position_size', 2)
        
        if current_pos_size < 1.5:
            return f"‚Ä¢ Augmenter Position Size: {current_pos_size:.1f}% ‚Üí 2.0% (plus agressif)"
        elif current_pos_size > 3:
            return f"‚Ä¢ R√©duire Position Size: {current_pos_size:.1f}% ‚Üí 2.5% (moins risqu√©)"
        else:
            return f"‚Ä¢ Position Size optimale: {current_pos_size:.1f}% (maintenir)"
    
    def optimize_exit_params(self, params, results):
        """Optimise les param√®tres de sortie"""
        trades = [t for t in results.get('trades', []) if t.get('action') == 'SELL']
        moon_shots = len([t for t in trades if t.get('return', 0) >= 100])
        
        recommendations = []
        
        if moon_shots > len(trades) * 0.15:
            recommendations.append("‚Ä¢ TP5 trop conservateur: 1200% ‚Üí 1500%")
        
        if len([t for t in trades if t.get('return', 0) < -15]) > len(trades) * 0.2:
            recommendations.append(f"‚Ä¢ Stop Loss: {params.get('stop_loss', -20):.0f}% ‚Üí -15% (moins agressif)")
        
        return "\n".join(recommendations) if recommendations else "‚Ä¢ Param√®tres de sortie optimaux"
    
    def optimize_detection_params(self, params, results):
        """Optimise les param√®tres de d√©tection"""
        return f"""
‚Ä¢ Seuil D√©tection: {params.get('detection_threshold', 30):.0f} ‚Üí 28 (plus sensible)
‚Ä¢ Holding Max: {params.get('max_holding_days', 8):.0f}j ‚Üí 10j (plus de patience)
‚Ä¢ Filtres suppl√©mentaires: Volume, Momentum, Social Sentiment
"""
    
    def generate_optimal_config(self, params, results):
        """G√©n√®re une configuration optimale"""
        return """
üíé CONFIGURATION OPTIMALE:
‚Ä¢ Capital Initial: $15,000 (diversification)
‚Ä¢ Position Size: 2.2%
‚Ä¢ Stop Loss: -18%
‚Ä¢ Take Profits: 30% | 75% | 180% | 450% | 1000% | 1500%
‚Ä¢ D√©tection: 28
‚Ä¢ Holding Max: 10 jours
"""
    
    def generate_benchmark_conclusion(self, our_return, btc_return, spy_return):
        """G√©n√®re une conclusion comparative"""
        if our_return > btc_return and our_return > spy_return:
            return "üèÜ SURPERFORMANCE TOTALE - Strat√©gie sup√©rieure aux benchmarks"
        elif our_return > max(btc_return, spy_return):
            return "‚úÖ SURPERFORMANCE PARTIELLE - Meilleure qu'un benchmark majeur"
        elif our_return > 0:
            return "‚öñÔ∏è PERFORMANCE POSITIVE - R√©sultats corrects mais inf√©rieurs aux benchmarks"
        else:
            return "‚ùå SOUS-PERFORMANCE - Strat√©gie moins efficace que les benchmarks"
    
    def generate_complete_report(self):
        """G√©n√®re un rapport complet pour export"""
        if not self.main_app.backtest_results:
            return "Aucune donn√©e disponible pour le rapport."
        
        results = self.main_app.backtest_results
        
        report = f"""
RAPPORT COMPLET D'ANALYSE - MEMECOIN TRADING BOT
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
G√©n√©r√© le: {np.datetime64('today')}

{self.generate_quick_analysis_text(results)}

{self.generate_detailed_analysis_text(results)}

{self.generate_ai_recommendations(results)}

{self.generate_optimization_suggestions(results)}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Fin du rapport - Memecoin Trading Bot Analysis Engine
        """
        
        return report
    
    def clear_analysis(self):
        """Efface le contenu de l'analyse"""
        self.analysis_text.delete("1.0", tk.END)
    
    def apply_text_formatting(self):
        """Applique le formatage au texte"""
        content = self.analysis_text.get("1.0", tk.END)
        lines = content.split('\n')
        
        for i, line in enumerate(lines):
            line_start = f"{i+1}.0"
            line_end = f"{i+1}.end"
            
            if "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" in line or "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" in line:
                continue
            elif line.strip().endswith("RAPPORT EX√âCUTIF") or line.strip().endswith("RAPPORT COMPLET"):
                self.analysis_text.tag_add("title", line_start, line_end)
            elif line.startswith("üí∞ SECTION") or line.startswith("üéØ SECTION") or line.startswith("üìà SECTION"):
                self.analysis_text.tag_add("section", line_start, line_end)
            elif "‚úÖ" in line or "üåü" in line:
                self.analysis_text.tag_add("success", line_start, line_end)
            elif "‚ö†Ô∏è" in line:
                self.analysis_text.tag_add("warning", line_start, line_end)
            elif "‚ùå" in line:
                self.analysis_text.tag_add("error", line_start, line_end)
            elif line.startswith("CONFIGURATION OPTIMALE") or "Moon Shot" in line:
                self.analysis_text.tag_add("highlight", line_start, line_end)
    
    def show_no_data_warning(self):
        """Affiche un avertissement d'absence de donn√©es"""
        self.clear_analysis()
        
        warning_text = """
‚ö†Ô∏è AUCUNE DONN√âE DISPONIBLE
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Pour g√©n√©rer une analyse, vous devez d'abord:

1. üìä Configurer les param√®tres du backtest
2. üöÄ Lancer un backtest complet
3. ‚è≥ Attendre la fin de l'ex√©cution
4. üîÑ Revenir dans cet onglet pour l'analyse

Une fois les donn√©es disponibles, l'IA pourra g√©n√©rer:
‚Ä¢ üéØ Analyses de performance d√©taill√©es
‚Ä¢ üí° Recommandations personnalis√©es
‚Ä¢ üìà Suggestions d'optimisation
‚Ä¢ üìä Rapports exportables

Lancez votre premier backtest pour commencer!
        """
        
        self.analysis_text.insert("1.0", warning_text)
        self.analysis_text.tag_add("warning", "1.0", "2.end")
    
    def generate_analysis(self, results):
        """G√©n√®re automatiquement l'analyse apr√®s un backtest"""
        self.clear_analysis()
        
        # G√©n√®re une analyse rapide par d√©faut
        analysis = self.generate_quick_analysis_text(results)
        self.analysis_text.insert("1.0", analysis)
        self.apply_text_formatting()
    
    def reset(self):
        """Reset l'onglet d'analyse"""
        self.show_initial_message()

print("Interface GUI compl√®te cr√©√©e! Maintenant cr√©ons les modules core et utils...")